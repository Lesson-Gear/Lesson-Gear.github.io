<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Blocks Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
        }

        #gameCanvas {
            display: block;
            background-color: #111;
            margin: 0 auto;
            border: 2px solid #fff;
        }

        .block {
            position: absolute;
            background-color: #fff;
        }

        .golden {
            background-color: gold;
        }

        .player {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #00f;
        }

    </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B11XZSTZ4E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B11XZSTZ4E');
</script>
<body>

    <div id="countdown" style="position: absolute; top: 7%; left: 50%; transform: translate(-50%, -50%); color: red; font-family: VT323, monospace; font-size: 30px; text-align: center;"></div>

    <script>
        const timeArray = [
            ["7:25", "no school", true], ["8:15", "Bell in:", false], ["9:00", "Bell in:", false],
            ["9:05", "Bell in:", false], ["9:50", "Bell in:", false], ["10:10", "Bell in:", false],
            ["10:55", "Bell in:", false], ["11:00", "Bell in:", false], ["11:45", "Bell in:", false],
            ["11:50", "Bell in:", false], ["12:35", "Bell in:", false], ["13:35", "Bell in:", false],
            ["14:20", "Bell in:", false], ["14:25", "Bell in:", false], ["15:10", "Bell in:", false],
            ["15:25", "Bell in:", false], ["16:15", "Bell in:", false], ["17:00", "Bell in:", false]
        ];

        function getNextTime() {
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            const currentSeconds = now.getSeconds();
            const currentTotalSeconds = currentMinutes * 60 + currentSeconds;
            const day = now.getDay();

            // Check if it's a weekend
            if (day === 0 || day === 6) {
                return { label: "Weekend", onlyLabel: true };
            }

            let nextEvent = timeArray
                .map(([timeString, label, onlyLabel]) => {
                    const [hours, minutes] = timeString.split(":").map(Number);
                    return {
                        timeInSeconds: hours * 3600 + minutes * 60,
                        label,
                        onlyLabel
                    };
                })
                .find(({ timeInSeconds }) => timeInSeconds > currentTotalSeconds);

            // If no future times found today, take the first event of the next day
            if (!nextEvent) {
                const [firstTimeString, firstLabel, firstOnlyLabel] = timeArray[0];
                const [firstHours, firstMinutes] = firstTimeString.split(":").map(Number);
                nextEvent = {
                    timeInSeconds: firstHours * 3600 + firstMinutes * 60 + 86400, // Add 24 hours
                    label: firstLabel,
                    onlyLabel: firstOnlyLabel
                };
            }

            // Calculate time difference
            const diff = nextEvent.timeInSeconds - currentTotalSeconds;
            const hours = Math.floor(diff / 3600) % 24;
            const minutes = Math.floor((diff % 3600) / 60);
            const seconds = diff % 60;

            return { hours, minutes, seconds, label: nextEvent.label, onlyLabel: nextEvent.onlyLabel };
        }

        function updateCountdown() {
            const next = getNextTime();
            const countdownElement = document.getElementById('countdown');
            if (next.onlyLabel) {
                countdownElement.innerText = next.label;
            } else {
                countdownElement.innerText = `${next.label} ${next.hours.toString().padStart(2, '0')}:${next.minutes.toString().padStart(2, '0')}:${next.seconds.toString().padStart(2, '0')}`;
            }
        }
    </script>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const playerWidth = 40;
        const playerHeight = 40;
        let playerX = canvas.width / 2 - playerWidth / 2;
        let playerY = canvas.height - playerHeight - 15;

        let blocks = [];
        let goldenBlock = null;
        let score = 0;
        let highScore = getHighScore();
        let gameOver = false;

        let scoreInterval;

        let velocityX = 0;

        let baseAcceleration = 0.05;

        
        let movingLeft = false;
        let movingRight = false;
        
        let originalSpeeds = [];

        let slowdownActive = false
        let goldrushActive = false

        let messages = [];

        function applySlowdown (time) {
            slowdownActive = true;
            
            setTimeout(() => {
                slowdownActive = false;
            }, time);
        };

        let isImmune = false;
        let immunityStart = 0;
        let immunityDuration = 0;
        let immunityTimeoutId = null;

        function applyImmunity(time) {
            if (isImmune && immunityTimeoutId) {
                clearTimeout(immunityTimeoutId);
            }

            isImmune = true;
            immunityStart = performance.now();
            immunityDuration = time;

            immunityTimeoutId = setTimeout(() => {
                isImmune = false;
                immunityTimeoutId = null; // cleanup
            }, time);
        }


        function triggerGoldRush() {
            let count = 0;
            let maxSpawns = 25; 
            let attempts = 0;
            goldrushActive = true

            let interval = setInterval(() => {
                if (Math.random() < 0.1) { 
                    spawnGoldRushBlock();
                    count++;
                }

                attempts++;

                if (count >= maxSpawns || attempts >= 20 * 20) {
                    clearInterval(interval);
                    goldrushActive = false
                }
            }, 60); 
        }


        function drawStatusMessages() {
            if (slowdownActive) {
                ctx.font = "20px VT323, monospace";
                ctx.fillStyle = 'green';
                const text = 'Slowdown Active';
                ctx.fillText(text, (canvas.width - ctx.measureText(text).width - 20), 50); 
            }

            if (isImmune) {
                ctx.font = "20px VT323, monospace";
                ctx.fillStyle = 'green';
                const text = 'Immunity Active';
                ctx.fillText(text, (canvas.width - ctx.measureText(text).width - 20), 50);
            }

            if (goldrushActive) {
                ctx.font = "20px VT323, monospace";
                ctx.fillStyle = 'green';
                const text = 'Gold Rush Active';
                ctx.fillText(text, (canvas.width - ctx.measureText(text).width - 20), 50);
            }
        }

        function createMessage(posX, posY, color, messageText, duration) {
            messages.push({
                x: posX,
                y: posY,
                color: color,
                text: messageText,
                expirationTime: performance.now() + duration
            });
        }

        function drawMessages() {
            const now = performance.now();
            messages.forEach((msg, index) => {
                if (now < msg.expirationTime) {
                    ctx.fillStyle = msg.color;
                    ctx.font = "20px VT323, monospace";
                    ctx.fillText(msg.text, msg.x, msg.y);
                } else {
                    messages.splice(index, 1);
                }
            });
        }


        function startScoreTimer() {
            if (!scoreInterval) {
                scoreInterval = setInterval(() => {
                    if (!gameOver) {
                        score += 1;
                    }
                }, 1000);
            }
        }

        function goldenBlockHit(posX, posY) {
            posY -= 5
            const outcomes = [
                { percentage: 44, action: () => {
                    score += 20;
                    createMessage(posX, posY, "green", "+20 Points", 1000);
                }},
                { percentage: 25, action: () => {
                    if (score > 150) {
                        applySlowdown(5000);
                    } else {
                        score += 20;
                        createMessage(posX, posY, "green", "+20 Points", 1000);
                    }
                }},
                { percentage: 20, action: () => applyImmunity(10000) },
                { percentage: 1, action: () => {
                    score += 200;
                    createMessage(posX, posY, "gold", "+200 Points", 1000);
                }},
                { percentage: 10, action: triggerGoldRush }
            ];

            let rand = Math.random() * 100;
            let cumulative = 0;

            for (let outcome of outcomes) {
                cumulative += outcome.percentage;
                if (rand < cumulative) {
                    outcome.action();
                    break;
                }
            }
        }


        function stopScoreTimer() {
            clearInterval(scoreInterval);
            scoreInterval = null;
        }

        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                stopScoreTimer();
            } else {
                startScoreTimer();
            }
        });
        function drawPlayer() {
            ctx.fillStyle = '#00f';
            ctx.fillRect(playerX, playerY, playerWidth, playerHeight);

        if (isImmune) {
            const elapsed = performance.now() - immunityStart;
            const remaining = immunityDuration - elapsed;

            ctx.lineWidth = 4;
            ctx.strokeStyle = `rgba(77, 139, 247, 0.5)`;
            ctx.shadowColor = `rgba(77, 139, 247, 0.5)`;
            ctx.shadowBlur = 12;
            ctx.strokeRect(playerX - 2, playerY - 2, playerWidth + 4, playerHeight + 4);

            if (remaining <= 3500) {
                const time = performance.now() / 100; 
                const alpha = 0.6 + 0.2 * Math.sin(time); 

                ctx.lineWidth = 4;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.shadowColor = `rgba(255, 255, 255, ${alpha})`;
                ctx.shadowBlur = 16;

                ctx.strokeRect(playerX - 2, playerY - 2, playerWidth + 4, playerHeight + 4);
            }
                ctx.shadowBlur = 0;
            }
        }




                function drawBlocks() {
                    for (let i = 0; i < blocks.length; i++) {
                        ctx.fillStyle = blocks[i].golden ? 'gold' : '#fff';
                        ctx.fillRect(blocks[i].x, blocks[i].y, blocks[i].width, blocks[i].height);
                    }

                    if (goldenBlock) {
                        ctx.fillStyle = 'gold';
                        ctx.fillRect(goldenBlock.x, goldenBlock.y, goldenBlock.width, goldenBlock.height);
                    }
                }

        function moveBlocks() {
            for (let i = 0; i < blocks.length; i++) {
                if (slowdownActive) {
                    blocks[i].y += (blocks[i].speed / 10); 
                } else {
                    blocks[i].y += blocks[i].speed;  
                }

                if (blocks[i].y > canvas.height) {
                    blocks.splice(i, 1);
                    i--;
                    continue;
                }

                let hitboxTolerance = 5; 

                if (blocks[i].y + blocks[i].height > playerY &&
                    blocks[i].y < playerY + playerHeight &&
                    blocks[i].x + blocks[i].width > playerX + hitboxTolerance &&
                    blocks[i].x < playerX + playerWidth - hitboxTolerance) {
                    
                    if (blocks[i].golden && (blocks[i].rushed ?? false) ){
                        score += 5
                        createMessage(playerX, playerY, "green", "+5 Points", 1000)
                        blocks.splice(i, 1);
                        i--;
                        continue;
                    }
                    else if(blocks[i].golden) {
                        goldenBlockHit(playerX, playerY);
                        blocks.splice(i, 1);
                        i--;
                        continue;
                    } else {
                        if (!isImmune) {
                            gameOver = true;
                            stopScoreTimer();
                        }
                    }
                }

            }
        }


        function spawnBlock() {
            const width = Math.random() * 40 + 35;
            var baseSpeed = Math.random() < 0.9 ? 2 : (Math.random() * (3.1 - 3) + 5);
            const speedIncrease = Math.sqrt(score) * 0.25;
            const speed = baseSpeed + speedIncrease;
            const x = Math.random() * (canvas.width - width);
            
            const block = { x, y: -50, width, height: 30, speed, golden: false };
            blocks.push(block);
        }

        function tryGoldenBlockSpawn() {
            const odds = 380; // 1 in x chance
            const goldenBlockExists = blocks.some(block => block.golden);
    
            if (!goldenBlockExists && Math.random() < 1 / odds) {
            spawnGoldenBlock();
            }
        }

        function spawnGoldenBlock() {
            const width = Math.random() * 50 + 30;
            const baseSpeed = 2;
            const speedIncrease = Math.sqrt(score) * 0.25;
            const speed = baseSpeed + speedIncrease;
            const x = Math.random() * (canvas.width - width);
            
            const newGoldenBlock = { x, y: -50, width, height: 30, speed, golden: true };
            blocks.push(newGoldenBlock);
        }

        function spawnGoldRushBlock() {
            const width = Math.random() * 50 + 30;
            const baseSpeed = 4;
            const speedIncrease = Math.sqrt(score) * 0.25;
            const speed = baseSpeed + speedIncrease;
            const x = Math.random() * (canvas.width - width);
            const y = Math.random() * (canvas.height - 30);
            
            const newGoldRushBlock = { x, y, width, height: 30, speed, golden: true, rushed: true };
            blocks.push(newGoldRushBlock);
        }

        function drawScore() {
            ctx.font = "20px VT323, monospace";
            ctx.fillStyle = '#fff';
            ctx.fillText(String(score).padStart(5, '0'), 10, 30);
        }
        
        function drawHighScore() {
            ctx.font = "20px VT323, monospace";
            ctx.fillStyle = '#fff';
            ctx.fillText('HI: '+(String(highScore).padStart(5, '0')), 10, 60);
        }
        
        function processGameOver () {
            if (score>highScore){
                setHighScore(score)
            }
        }
        function drawGameOver() {
            ctx.font = "40px VT323, monospace";
            ctx.fillStyle = '#fff';
            let text = "Game Over";
            let textWidth = ctx.measureText(text).width;
            ctx.fillText(text, (canvas.width - textWidth) / 2, canvas.height / 2);

            ctx.font = "20px VT323, monospace";
            text = "Press space to play again";
            textWidth = ctx.measureText(text).width;
            ctx.fillText(text, (canvas.width - textWidth) / 2, canvas.height / 2 + 40);
        }


        function resetGame() {
            playerX = canvas.width / 2 - playerWidth / 2;
            playerY = canvas.height - playerHeight - 15;
            blocks = [];
            score = 0;
            gameOver = false;
            highScore = getHighScore();
            startScoreTimer();
            gameLoop();
        }

        document.addEventListener('keydown', function (e) {
            if (e.code === 'Space' && gameOver) {
                resetGame();
            }
        });


        function setHighScore(score) {
            document.cookie = `highscore=${score}; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/`;
        }

        function getHighScore() {
            const cookies = document.cookie.split('; ');
            for (let cookie of cookies) {
                let [name, value] = cookie.split('=');
                if (name === 'highscore') {
                    return parseInt(value, 10) || 0;
                }
            }
            return 0;
        }

        function updatePlayer() {
            baseSpeed = 5 + (Math.log(score + 1) * 0.3);

            if (movingLeft) velocityX = -baseSpeed;
            if (movingRight) velocityX = baseSpeed;

            if (!movingLeft && !movingRight) {
                if (velocityX > 0) velocityX -= baseAcceleration;
                else if (velocityX < 0) velocityX += baseAcceleration;

                if (velocityX < 0) velocityX = 0;
                if (velocityX > 0) velocityX = 0;
            }

            playerX += velocityX;

            if (playerX < 0) playerX = 0;
            if (playerX + playerWidth > canvas.width) playerX = canvas.width - playerWidth;
        }


        function gameLoop() {
            if (gameOver) {
                processGameOver();
                drawGameOver();
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            setInterval(updateCountdown, 1000);
            updateCountdown();
            drawStatusMessages();
            updatePlayer();
            moveBlocks();
            drawBlocks();
            drawScore();
            drawHighScore();
            tryGoldenBlockSpawn();
            drawMessages();

            let spawnProbability = 0.02 + Math.log(score + 1) * 0.005;
            if (slowdownActive) {
                spawnProbability /= 10;
            }
            if (Math.random() < spawnProbability) {
                spawnBlock();
            }
            requestAnimationFrame(gameLoop);
        }

        let lastDirection = null;

        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                if (lastDirection !== 'left') {
                    velocityX = 0; 
                    lastDirection = 'left';
                }
                movingLeft = true;
            }
            if (e.key === 'ArrowRight' || e.key === 'd') {
                if (lastDirection !== 'right') {
                    velocityX = 0;
                    lastDirection = 'right';
                }
                movingRight = true;
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') movingLeft = false;
            if (e.key === 'ArrowRight' || e.key === 'd') movingRight = false;
        });



        startScoreTimer();
        gameLoop();
    </script>
</body>
</html>
